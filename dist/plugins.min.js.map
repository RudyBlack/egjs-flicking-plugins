{"version":3,"file":"plugins.min.js","sources":["../src/Parallax.ts","../src/Fade.ts","../src/AutoPlay.ts"],"sourcesContent":["import Flicking, { EVENTS, Plugin } from \"@egjs/flicking\";\n\n/**\n * You can apply parallax effect while panel is moving.\n * @ko 패널들을 움직이면서 parallax 효과를 부여할 수 있습니다.\n * @memberof Flicking.Plugins\n */\nclass Parallax implements Plugin {\n  private _flicking: Flicking | null;\n\n  /* Options  */\n  private _selector: string;\n  private _scale: number;\n\n  public get selector() { return this._selector; }\n  public get scale() { return this._scale; }\n\n  public set selector(val: string) { this._selector = val; }\n  public set scale(val: number) { this._scale = val; }\n\n  /**\n   * @param {string} selector Selector of the element to apply parallax effect<ko> Parallax 효과를 적용할 엘리먼트의 선택자 </ko>\n   * @param {number} scale Effect amplication scale<ko>효과 증폭도</ko>\n   * @example\n   * ```ts\n   * flicking.addPlugins(new Parallax(\"img\", 1));\n   * ```\n   */\n  public constructor(selector = \"\", scale = 1) {\n    this._flicking = null;\n    this._selector = selector;\n    this._scale = scale;\n  }\n\n  public init(flicking: Flicking): void {\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n\n    flicking.on(EVENTS.MOVE, this._onMove);\n    flicking.on(EVENTS.AFTER_RESIZE, this.update);\n    this._onMove();\n  }\n\n  public destroy(): void {\n    if (!this._flicking) return;\n\n    this._flicking.off(EVENTS.MOVE, this._onMove);\n    this._flicking = null;\n  }\n\n  public update = (): void => {\n    this._onMove();\n  };\n\n  private _onMove = (): void => {\n    const flicking = this._flicking;\n\n    if (!flicking) return;\n\n    const panels = flicking.visiblePanels;\n\n    panels.forEach(panel => {\n      const progress = panel.outsetProgress;\n      const el = panel.element;\n      const target = this._selector ? el.querySelector<HTMLElement>(this._selector)! : el;\n      const parentTarget = target.parentNode as Element;\n      const rect = target.getBoundingClientRect();\n      const parentRect = parentTarget.getBoundingClientRect();\n      const position = (parentRect.width - rect.width) / 2 * progress * this._scale;\n      const transform = `translate(-50%) translate(${position}px)`;\n      const style = target.style;\n\n      style.cssText += `transform: ${transform};-webkit-transform: ${transform};-ms-transform:${transform}`;\n    });\n  };\n}\nexport default Parallax;\n","import Flicking, { EVENTS, Plugin } from \"@egjs/flicking\";\n\n/**\n * You can apply fade in / out effect while panel is moving.\n * @ko 패널들을 움직이면서 fade in / out 효과를 부여할 수 있습니다.\n * @memberof Flicking.Plugins\n */\nclass Fade implements Plugin {\n  private _flicking: Flicking | null;\n\n  /* Options  */\n  private _selector: string;\n  private _scale: number;\n\n  public get selector() { return this._selector; }\n  public get scale() { return this._scale; }\n\n  public set selector(val: string) { this._selector = val; }\n  public set scale(val: number) { this._scale = val; }\n\n  /**\n   * @param - The selector of the element to which the fade effect is to be applied. If the selector is blank, it applies to panel element. <ko>Fade 효과를 적용할 대상의 선택자. 선택자가 공백이면 패널 엘리먼트에 적용된다.</ko>\n   * @param - Effect amplication scale<ko>효과 증폭도</ko>\n   * @example\n   * ```ts\n   * flicking.addPlugins(new Fade(\"p\", 1));\n   * ```\n   */\n  public constructor(selector = \"\", scale = 1) {\n    this._flicking = null;\n    this._selector = selector;\n    this._scale = scale;\n  }\n\n  public init(flicking: Flicking): void {\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    this._flicking = flicking;\n\n    flicking.on(EVENTS.MOVE, this._onMove);\n    flicking.on(EVENTS.AFTER_RESIZE, this.update);\n    this._onMove();\n  }\n\n  public destroy(): void {\n    if (!this._flicking) return;\n\n    this._flicking.off(EVENTS.MOVE, this._onMove);\n    this._flicking = null;\n  }\n\n  public update = (): void => {\n    this._onMove();\n  };\n\n  private _onMove = (): void => {\n    const flicking = this._flicking;\n    const selector = this._selector;\n    const scale = this._scale;\n\n    if (!flicking) return;\n\n    const panels = flicking.visiblePanels;\n\n    panels.forEach(panel => {\n      const progress = panel.outsetProgress;\n      const el = panel.element;\n      const target = selector ? el.querySelector<HTMLElement>(selector)! : el;\n      const opacity = Math.min(1, Math.max(0, (1 - Math.abs(progress * scale))));\n\n      target.style.opacity = `${opacity}`;\n    });\n  };\n}\n\nexport default Fade;\n","import Flicking, { EVENTS, Plugin, DIRECTION } from \"@egjs/flicking\";\n\ninterface AutoPlayOptions {\n  duration: number;\n  direction: typeof DIRECTION[\"NEXT\"] | typeof DIRECTION[\"PREV\"];\n  stopOnHover: boolean;\n}\n\n/**\n * Plugin that allow you to automatically move to the next/previous panel, on a specific time basis\n * @ko 일정 시간마다, 자동으로 다음/이전 패널로 넘어가도록 할 수 있는 플러그인\n * @memberof Flicking.Plugins\n */\nclass AutoPlay implements Plugin {\n  /* Options */\n  private _duration: AutoPlayOptions[\"duration\"];\n  private _direction: AutoPlayOptions[\"direction\"];\n  private _stopOnHover: AutoPlayOptions[\"stopOnHover\"];\n\n  /* Internal Values */\n  private _flicking: Flicking | null = null;\n  private _timerId = 0;\n  private _mouseEntered = false;\n\n  public get duration() { return this._duration; }\n  public get direction() { return this._direction; }\n  public get stopOnHover() { return this._stopOnHover; }\n\n  public set duration(val: number) { this._duration = val; }\n  public set direction(val: AutoPlayOptions[\"direction\"]) { this._direction = val; }\n  public set stopOnHover(val: boolean) { this._stopOnHover = val; }\n\n  /**\n   * @param {AutoPlayOptions} options Options for the AutoPlay instance.<ko>AutoPlay 옵션</ko>\n   * @param {number} options.duration Time to wait before moving on to the next panel.<ko>다음 패널로 움직이기까지 대기 시간</ko>\n   * @param {\"PREV\" | \"NEXT\"} options.direction The direction in which the panel moves.<ko>패널이 움직이는 방향</ko>\n   * @param {boolean} options.stopOnHover Whether to stop when mouse hover upon the element.<ko>엘리먼트에 마우스를 올렸을 때 AutoPlay를 정지할지 여부</ko>\n   * @example\n   * ```ts\n   * flicking.addPlugins(new AutoPlay({ duration: 2000, direction: \"NEXT\" }));\n   * ```\n   */\n  public constructor({\n    duration = 2000,\n    direction = DIRECTION.NEXT,\n    stopOnHover = false\n  }: Partial<AutoPlayOptions> = {}) {\n    this._duration = duration;\n    this._direction = direction;\n    this._stopOnHover = stopOnHover;\n  }\n\n  public init(flicking: Flicking): void {\n    if (this._flicking) {\n      this.destroy();\n    }\n\n    flicking.on({\n      [EVENTS.MOVE_START]: this.stop,\n      [EVENTS.HOLD_START]: this.stop,\n      [EVENTS.MOVE_END]: this.play,\n      [EVENTS.SELECT]: this.play\n    });\n\n    this._flicking = flicking;\n    if (this._stopOnHover) {\n      const targetEl = this._flicking.element;\n      targetEl.addEventListener(\"mouseenter\", this._onMouseEnter, false);\n      targetEl.addEventListener(\"mouseleave\", this._onMouseLeave, false);\n    }\n\n    this.play();\n  }\n\n  public destroy(): void {\n    const flicking = this._flicking;\n\n    this._mouseEntered = false;\n    this.stop();\n\n    if (!flicking) {\n      return;\n    }\n\n    flicking.off(EVENTS.MOVE_START, this.stop);\n    flicking.off(EVENTS.HOLD_START, this.stop);\n    flicking.off(EVENTS.MOVE_END, this.play);\n    flicking.off(EVENTS.SELECT, this.play);\n\n    const targetEl = flicking.element;\n    targetEl.removeEventListener(\"mouseenter\", this._onMouseEnter, false);\n    targetEl.removeEventListener(\"mouseleave\", this._onMouseLeave, false);\n\n    this._flicking = null;\n  }\n\n  public update(): void {\n    // DO-NOTHING\n  }\n\n  public play = () => {\n    const flicking = this._flicking;\n    const direction = this._direction;\n\n    if (!flicking) {\n      return;\n    }\n\n    this.stop();\n\n    if (this._mouseEntered || flicking.animating) {\n      return;\n    }\n\n    this._timerId = window.setTimeout(() => {\n      if (direction === DIRECTION.NEXT) {\n        flicking.next().catch(() => void 0);\n      } else {\n        flicking.prev().catch(() => void 0);\n      }\n\n      this.play();\n    }, this._duration);\n  };\n\n  public stop = () => {\n    clearTimeout(this._timerId);\n  };\n\n  private _onMouseEnter = () => {\n    this._mouseEntered = true;\n    this.stop();\n  };\n\n  private _onMouseLeave = () => {\n    this._mouseEntered = false;\n    this.play();\n  };\n}\n\nexport default AutoPlay;\n"],"names":["selector","scale","_this","_onMove","flicking","_flicking","visiblePanels","forEach","panel","progress","outsetProgress","el","element","target","_selector","querySelector","parentTarget","parentNode","rect","getBoundingClientRect","transform","width","_scale","style","cssText","Object","this","val","destroy","on","EVENTS","MOVE","AFTER_RESIZE","update","off","opacity","Math","min","max","abs","_a","_b","_c","duration","_d","direction","DIRECTION","NEXT","_e","stopOnHover","_direction","stop","_mouseEntered","animating","_timerId","window","setTimeout","next","catch","prev","play","_duration","clearTimeout","_stopOnHover","MOVE_START","HOLD_START","MOVE_END","SELECT","targetEl","addEventListener","_onMouseEnter","_onMouseLeave","removeEventListener"],"mappings":"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"}